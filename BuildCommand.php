<?php

use Nette\Utils\Strings as String;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Helper\ProgressHelper;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\DomCrawler\Crawler;
use Symfony\Component\Finder\Finder;


class BuildCommand extends Command
{

	const MIN_VERSION = '2.8.0';
	const MAX_VERSION = '3.0.0';

	const DEFAULT_OUTPUT = './docset.sqlite';

	private $db;


	protected function configure()
	{
		$this
			->setName('build')
			->setDescription('Build token database from ApiGen html')
			->addArgument(
				'docDir',
				InputArgument::REQUIRED,
				'Path to root of ApiGen generated documentation'
			)
			->addOption(
				'output',
				'o',
				InputOption::VALUE_REQUIRED,
				'Output path â€“ defaults to ' . self::DEFAULT_OUTPUT
			)
		;
	}

	private function insert($type, $name, $path)
	{
		$this->db->query("INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?)",
			$name, ucFirst($type), $path);
	}

	private function getFiles($docDir)
	{
		$finder = new Finder();
		return $finder->files()
			->name('*-*.html')
			->notName('source-*')
			->notName('namespace-None*')
			->notName('namespace-PHP*')
			->depth(0)->in($docDir);
	}

	protected function execute(InputInterface $input, OutputInterface $output)
	{
		$docDir = $input->getArgument('docDir');
		$parser = new DocParser($docDir);

		$genVer = $parser->generatorVersion;

		$output->writeln("Parsing documentation generated by ApiGen $genVer...");
		if (version_compare($genVer, self::MIN_VERSION, '<'))
		{
			$output->writeln("<info>This tool is not tested against ApiGen < " . self::MIN_VERSION . "</info>");
		}
		elseif (version_compare($genVer, self::MAX_VERSION, '>='))
		{
			$output->writeln("<info>This tool is not tested against ApiGen >= " . self::MAX_VERSION . "</info>");
		}

		$files = $this->getFiles($docDir);

		$progress = new ProgressHelper();
		$progress->start($output, count($files));

		$outputFile = $input->getOption('output');
		if (!trim($outputFile))
		{
			$outputFile = self::DEFAULT_OUTPUT;
		}
		if (file_exists($outputFile))
		{
			unlink($outputFile);
		}

		$conn = new Nette\Database\Connection("sqlite:$outputFile");
		$this->db = new Nette\Database\Context($conn);
		$this->db->query('CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);');
		$this->db->query('CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);');

		foreach ($files as $file)
		{
			$crawler = new Crawler(file_get_contents($file->getRealPath()));
			$name = $crawler->filterXPath('//title')->text();

			$match = String::match($name, '~^(?P<type>[^\s]+) (?P<name>[^\s]+)\s+\|~');
			$type = strToLower($match['type']);

			if ($type === 'class' && String::match($match['name'], '~Exception$~'))
			{
				$type = 'exception';
			}

			if ($type === 'subpackage')
			{
				$type = 'package';
				$m = String::match($name, '~ \| Package (?P<package>[^\s]+)\s+\|~');
				$match['name'] = "{$m['package']}\\{$match['name']}";
				echo $match['name'] . "\n";
			}

			if (in_array($type, ['class', 'exception', 'interface']))
			{
				foreach ($crawler->filterXPath('//*[@id="methods"]/tr') as $method)
				{
					$id = $method->getAttribute('id');
					$name = substr($id, 1); // remove initial underscore
					if (String::startsWith($name, '_'))
					{
						continue;
					}
					$this->insert('method', $match['name'] . "::$name()", $file->getBasename() . "#$id");
				}
				foreach ($crawler->filterXPath('//*[@id="properties"]/tr') as $method)
				{
					$name = $id = $method->getAttribute('id');
					$this->insert('property', $match['name'] . "::$name", $file->getBasename() . "#$id");
				}
				foreach ($crawler->filterXPath('//*[@id="magicProperties"]/tr') as $method)
				{
					$id = $method->getAttribute('id');
					$name = substr($id, 1); // remove initial m (stands for magical)
					$this->insert('property', $match['name'] . "::$name", $file->getBasename() . "#$id");
				}
				foreach ($crawler->filterXPath('//*[@id="constants"]/tr') as $method)
				{
					$name = $id = $method->getAttribute('id');
					$this->insert('constant', $match['name'] . "::$name", $file->getBasename() . "#$id");
				}

			}

			$this->insert($type, $match['name'], $file->getBasename());
			$progress->advance();
		}
		$progress->finish();

		$output->writeln("Done building database");
	}
}
