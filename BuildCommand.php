<?php

use Nette\Utils\Strings as String;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Helper\ProgressHelper;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\DomCrawler\Crawler;
use Symfony\Component\Finder\Finder;


class BuildCommand extends Command
{

	const MIN_VERSION = '2.8.0';
	const MAX_VERSION = '3.0.0';

	const DEFAULT_OUTPUT = './docset.sqlite';

	private $db;


	protected function configure()
	{
		$this
			->setName('build')
			->setDescription('Build Docset database from ApiGen html')
			->addArgument(
				'path',
				InputArgument::REQUIRED,
				'Path to root of ApiGen generated documentation'
			)
			->addArgument(
				'output',
				InputArgument::OPTIONAL,
				'Output path â€“ defaults to ' . self::DEFAULT_OUTPUT
			)
		;
	}

	private function insert($type, $name, $path)
	{
		$this->db->query("INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?)", 
			$name, ucFirst($type), $path);
	}

	protected function execute(InputInterface $input, OutputInterface $output)
	{
		$path = $input->getArgument('path');
		if (!is_dir($path))
		{
			$output->writeln("<error>$path is not a valid directory</error>");
			return FALSE;
		}

		$index = "$path/index.html";
		if (!file_exists($index))
		{
			$output->writeln("<error>$path is not root of ApiGen documentation: index.html not found</error>");
			return FALSE;
		}

		$crawler = new Crawler(file_get_contents($index));
		$meta = $crawler->filterXPath('//meta[@name="generator"]')->first();
		$generator = $meta->attr('content');
		$genVer = substr($generator, strlen('ApiGen '));

		$output->writeln("Parsing documentation generated by $generator...");
		if (version_compare($genVer, self::MIN_VERSION, '<'))
		{
			$output->writeln("<info>This tool is not tested against ApiGen < " . self::MIN_VERSION . "</info>");
		}
		elseif (version_compare($genVer, self::MAX_VERSION, '>='))
		{
			$output->writeln("<info>This tool is not tested against ApiGen >= " . self::MAX_VERSION . "</info>");
		}

		$finder = new Finder();
		$files = $finder->files()
			->name('*-*.html')
			->notName('source-*')
			->notName('namespace-None*')
			->notName('namespace-PHP*')
			->depth(0)->in($path);

		$progress = new ProgressHelper();
		$progress->start($output, count($files));

		$outputFile = $input->getArgument('output');
		if (!trim($outputFile))
		{
			$outputFile = self::DEFAULT_OUTPUT;
		}
		if (file_exists($outputFile))
		{
			unlink($outputFile);
		}

		$conn = new Nette\Database\Connection("sqlite:$outputFile");
		$this->db = new Nette\Database\Context($conn);
		$this->db->query('CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);');
		$this->db->query('CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);');

		foreach ($files as $file)
		{
			$crawler = new Crawler(file_get_contents($file->getRealPath()));
			$name = $crawler->filterXPath('//title')->text();

			$match = String::match($name, '~(?P<type>[^\s]+) (?P<name>[^\s]+)\s+|~');
			$type = strToLower($match['type']);

			if ($type === 'class' && String::match($match['name'], '~Exception$~'))
			{
				$type = 'exception';
			}

			if (in_array($type, ['class', 'exception', 'interface']))
			{
				foreach ($crawler->filterXPath('//*[@id="methods"]/tr') as $method)
				{
					$id = $method->getAttribute('id');
					$name = substr($id, 1); // remove initial underscore

					$this->insert('method', $match['name'] . "::$name()", $file->getBasename() . "#$id");
				}
				foreach ($crawler->filterXPath('//*[@id="properties"]/tr') as $method)
				{
					$this->insert('property', $match['name'] . "::$name", $file->getBasename() . "#$id");
				}
				foreach ($crawler->filterXPath('//*[@id="magicProperties"]/tr') as $method)
				{
					$id = $method->getAttribute('id');
					$name = substr($id, 1); // remove initial m (stands for magical)
					$this->insert('property', $match['name'] . "::$name", $file->getBasename() . "#$id");
				}
				foreach ($crawler->filterXPath('//*[@id="constants"]/tr') as $method)
				{
					$name = $id = $method->getAttribute('id');
					$this->insert('constant', $match['name'] . "::$name", $file->getBasename() . "#$id");
				}
				
			}

			$this->insert($type, $match['name'], $file->getBasename());
			$progress->advance();
		}
		$progress->finish();

		$output->writeln("Done building database");
	}
}
